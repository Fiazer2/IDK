-- \\ Krypton Reanimate, Author: @xyzkade/@gelatekforever. https://github.com/KadeTheExploiter/Krypton/ //
-- || 1.7.1 Jeez, I didn't know it was THAT BAD.
-- // kitty kitty rawr

local KryptonSetConfig = KryptonConfiguration or Configuration or {}
local RigName = KryptonSetConfig.RigName or "Evolution, it must've passed you by."
local WaitTime = KryptonSetConfig.WaitTime or 0.251
local TeleportOffsetRadius = KryptonSetConfig.TeleportOffsetRadius or 21
local Flinging = KryptonSetConfig.Flinging or nil
local NoBodyNearby = KryptonSetConfig.NoBodyNearby or nil
local AntiVoiding = KryptonSetConfig.AntiVoiding or nil
local NoCollisions = KryptonSetConfig.NoCollisions or Flinging or nil
local LimitHatsPerLimb = KryptonSetConfig.LimitHatsPerLimb or nil
local DisableCharacterScripts = KryptonSetConfig.DisableCharacterScripts or nil

-- Alias bien définis
local DefaultHats = {}

-- Fonction raccourcie pour les rotations
local function rot(x, y, z)
    return CFrame.Angles(math.rad(x), math.rad(y), math.rad(z))
end

-- Zéro CFrame pour les MeshPartAccessory du torse
local cf0 = CFrame.new()

local DefaultHats = {
    ["Right Arm"] = {
        {
            Texture = "", 
            Mesh    = "rbxassetid://105141400603933", 
            Name    = "RARM", 
            C0      = rot(0, 0, 90),
        },
        {
            Texture = "rbxassetid://4645402630", 
            Mesh    = "rbxassetid://3030546036", 
            Name    = "International Fedora", 
            C0      = rot(-90, 0, 90),
        },
    },

    ["Left Arm"] = {
        {
            Texture = "", 
            Mesh    = "rbxassetid://90736849096372", 
            Name    = "LARM", 
            C0      = rot(0, 0, 90),
        },
        {
            Texture = "rbxassetid://3650139425", 
            Mesh    = "rbxassetid://3030546036", 
            Name    = "International Fedora", 
            C0      = rot(-90, 0, -90),
        },
    },

    ["Right Leg"] = {
        {
            Texture = "", 
            Mesh    = "rbxassetid://99608462237958", 
            Name    = "Accessory (RARM)", 
            C0      = rot(0, 0, 90),
        },
        {
            Texture = "rbxassetid://4622077774", 
            Mesh    = "rbxassetid://3030546036", 
            Name    = "International Fedora", 
            C0      = rot(-90, 0, 90),
        },
    },

    ["Left Leg"] = {
        {
            Texture = "", 
            Mesh    = "rbxassetid://139733645770094", 
            Name    = "Accessory (LARM)", 
            C0      = rot(0, 0, 90),
        },
        {
            Texture = "rbxassetid://3860099469", 
            Mesh    = "rbxassetid://3030546036", 
            Name    = "International Fedora", 
            C0      = rot(-90, 0, -90),
        },
    },

    ["Torso"] = {
        {
            Texture = "", 
            Mesh    = "rbxassetid://138364679836274", 
            Name    = "MeshPartAccessory", 
            C0      = cf0,
        },
        {
            Texture = "", 
            Mesh    = "rbxassetid://138364679836274", 
            Name    = "MeshPartAccessory", 
            C0      = cf0,
        },
    },
}

local Hats = KryptonSetConfig.Hats or DefaultHats

local IsA = game.IsA
local Clone = game.Clone
local FindFirstChildOfClass = game.FindFirstChildOfClass
local FindFirstChild = game.FindFirstChild
local WaitForChild = game.WaitForChild
local GetChildren = game.GetChildren
local GetDescendants = game.GetDescendants

local RespawnEvent = Instance.new("BindableEvent")

local TeleportOffset = Vector3.zero
local ReverseSleep = TeleportOffset
local SafeYAxis = 35

local CameraHandle = nil
local AnimationHandlingFunction = nil

local HatsWithDifferentAligns = {}
local FlingableTargets = {}
local TempSignals = {}
local RBXSignals = {}
local Joints = {}
local Blacklist = {}
local HatsInUse = {}

local Workspace = FindFirstChildOfClass(game, "Workspace")
local Players = FindFirstChildOfClass(game, "Players")
local RunService = FindFirstChildOfClass(game, "RunService")
local StarterGui = FindFirstChildOfClass(game, "StarterGui")
local UserInputService = FindFirstChildOfClass(game, "UserInputService")

local Camera = Workspace.CurrentCamera
local PreviousCameraCFrame = Camera.CFrame

local function GetInstanceWithTime(Parent: Instance, Class: string, Name: string | nil, Timeout: number)
	local CurTime = 0

	while Timeout > CurTime do
		for _, v in GetChildren(Parent) do
			if IsA(v, Class) and (not Name or v.Name == Name) then
				return v
			end
		end

		CurTime += task.wait(0)
	end
end

local Terrain = GetInstanceWithTime(Workspace, "Terrain", "Terrain", 3)

if FindFirstChild(Terrain, RigName) then
	error("Reanimate is already running.", 2)
	return
end

if WaitTime < 0.16 then
	WaitTime = 0
end

local Player = Players.LocalPlayer
local Mouse = Player:GetMouse()

local Character = Player.Character or Player.CharacterAdded:Wait() and Player.Character

local Humanoid = GetInstanceWithTime(Character, "Humanoid", nil, 3)
local RootPart = GetInstanceWithTime(Character, "Part", "HumanoidRootPart", 3)
local Descendants = GetDescendants(Character)

local CFrameBackup = AntiVoiding and RootPart.CFrame or CFrame.identity
local FallenPartsDestroyHeight = Workspace.FallenPartsDestroyHeight + 100

local CanCallSimRadius = KryptonSetConfig.SetSimulationRadius and 
							pcall(function() Player.SimulationRadius = 1000 end)

-- // RunTime: Creating FakeRig

local FakeRig = Instance.new("Model")
local FakeHumanoid = Instance.new("Humanoid")
local FakeRigChildren = {}
local FakeRoot = nil

local SetStateEnabled = FakeHumanoid.SetStateEnabled
local ChangeState = FakeHumanoid.ChangeState
local Move = FakeHumanoid.Move

local BreakJoints = FakeRig.BreakJoints
local SetCoreGuiEnabled = StarterGui.SetCoreGuiEnabled
local SetCore = StarterGui.SetCore

local function CancelScript()
	local RootCFrame = FakeRoot.CFrame
	
	if KryptonSetConfig.PermanentDeath and replicatesignal then
		replicatesignal(Player, ConnectDiedSignalBackend)
	end
	
	for _, Signal in RBXSignals do
		Signal:Disconnect()
	end

	StarterGui:SetCore("ResetButtonCallback", true)
	Camera.CameraSubject = Character
	FakeRig:Destroy()

	-- Free the memory after use.

	table.clear(Hats)
	table.clear(HatsInUse)
	table.clear(RBXSignals)
	table.clear(FakeRigChildren)
	table.clear(Joints)
	table.clear(HatsWithDifferentAligns)
	table.clear(FlingableTargets)
	table.clear(TempSignals)
	table.clear(DefaultHats)
	table.clear(Descendants)

	if KryptonSetConfig.ReturnOnDeath then
		local Target = Player.CharacterAdded:Wait()
		local Root = GetInstanceWithTime(Target, "Part", "HumanoidRootPart", 3)
		
		if Root then
			Root.CFrame = RootCFrame
		end
	end
end

do -- [[ Scoped Rig Creating. ]]
	local Transparency = KryptonSetConfig.OverlayFakeCharacter and 0.5 or 1
	local HumanoidDesc = Instance.new("HumanoidDescription")
	local Animator = Instance.new("Animator")
	local Animate = Instance.new("LocalScript")

	local function MakeMotor6D(Name, Part0, Part1, C0, C1)
		local Joint = Instance.new("Motor6D")

		Joint.Name = Name
		Joint.Part0 = Part0
		Joint.Part1 = Part1
		Joint.C0 = C0
		Joint.C1 = C1

		Joint.Parent = Part0
		Joints[Name] = Joint

		return Joint
	end

	local function MakeAttachment(Name, CFrame, Parent)
		local Attachment = Instance.new("Attachment")

		Attachment.Name = Name
		Attachment.CFrame = CFrame
		Attachment.Parent = Parent
	end

	local Torso = Instance.new("Part")
	local RightArm = Instance.new("Part")
	local Head = Instance.new("Part")
	DefaultAccessoryPart1 = Head

	Head.Size = Vector3.new(2, 1, 1)
	Torso.Size = Vector3.new(2, 2, 1)
	RightArm.Size = Vector3.new(1, 2, 1)

	Head.Transparency = Transparency
	Torso.Transparency = Transparency
	RightArm.Transparency = Transparency

	FakeRoot = Clone(Torso);
	FakeRoot.CanCollide = nil

	local LeftArm = Clone(RightArm)
	local RightLeg = Clone(RightArm)
	local LeftLeg = Clone(RightArm)

	local Motor6Ds = {
		Neck = {
			Torso,
			Head,
			CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
			CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
		},
		RootJoint = {
			FakeRoot,
			Torso,
			CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
			CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
		},
		['Right Shoulder'] = {
			Torso,
			RightArm,
			CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
			CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		},
		['Left Shoulder'] = {
			Torso,
			LeftArm,
			CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
			CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
		},
		['Right Hip'] = {
			Torso,
			RightLeg,
			CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
			CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
		},
		['Left Hip'] = {
			Torso,
			LeftLeg,
			CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
			CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
		}
	}

	local Attachments = {
		HairAttachment = { CFrame.new(0, 0.6, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head },
		HatAttachment = { CFrame.new(0, 0.6, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head },
		FaceFrontAttachment = { CFrame.new(0, 0, -0.6, 1, 0, 0, 0, 1, 0, 0, 0, 1), Head },
		RootAttachment = { CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), FakeRoot },
		LeftShoulderAttachment = { CFrame.new(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftArm },
		LeftGripAttachment = { CFrame.new(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftArm },
		RightShoulderAttachment = { CFrame.new(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightArm },
		RightGripAttachment = { CFrame.new(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightArm },
		LeftFootAttachment = { CFrame.new(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), LeftLeg },
		RightFootAttachment = { CFrame.new(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), RightLeg },
		NeckAttachment = { CFrame.new(0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		BodyFrontAttachment = { CFrame.new(0, 0, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		BodyBackAttachment = { CFrame.new(0, 0, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		LeftCollarAttachment = { CFrame.new(-1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		RightCollarAttachment = { CFrame.new(1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		WaistFrontAttachment = { CFrame.new(0, -1, -0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		WaistCenterAttachment = { CFrame.new(0, -1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
		WaistBackAttachment = { CFrame.new(0, -1, 0.5, 1, 0, 0, 0, 1, 0, 0, 0, 1), Torso },
	}

	for Name, Value in Motor6Ds do
		MakeMotor6D(Name, Value[1], Value[2], Value[3], Value[4])	
	end

	for Name, Table in Attachments do
		MakeAttachment(Name, Table[1], Table[2])
	end

	if KryptonSetConfig.AccessoryFallbackDefaults then
		local Types = { Name = "string", Texture = "string", Mesh = "string", Offset = "CFrame" }

		for Name, Data in DefaultHats do
			local HatsData = Hats[Name]
			local Flagged = nil

			if HatsData and typeof(HatsData) == "table" then
				for _, Hat in HatsData do
					for Key, Type in Types do
						if typeof(Hat[Key]) ~= Type then
							Flagged = true
							break
						end
					end
				end
			else
				Flagged = true
			end

			if Flagged then
				Hats[Name] = table.clone(Data)
			end
		end
	end

	table.clear(Attachments)
	table.clear(Motor6Ds)

	FakeRoot.Name = "HumanoidRootPart"
	Torso.Name = "Torso"
	Head.Name = "Head"
	RightArm.Name = "Right Arm"
	LeftArm.Name = "Left Arm"
	RightLeg.Name = "Right Leg"
	LeftLeg.Name = "Left Leg"

	Animator.Parent = FakeHumanoid
	HumanoidDesc.Parent = FakeHumanoid

	FakeHumanoid.Parent = FakeRig
	FakeRoot.Parent = FakeRig
	Head.Parent = FakeRig

	Torso.Parent = FakeRig
	RightArm.Parent = FakeRig
	LeftArm.Parent = FakeRig
	RightLeg.Parent = FakeRig
	LeftLeg.Parent = FakeRig
	FakeHumanoid.Parent = FakeRig

	Animate.Name = "Animate"
	Animate.Parent = FakeRig

	FakeRig.Name = RigName
	FakeRig.PrimaryPart = Head

	if FakeRigScale then
		FakeRig:ScaleTo(FakeRigScale)
		FakeRoot.CFrame = RootPart.CFrame * CFrame.new(0, FakeRigScale + 0.1, 0)
	else
		FakeRoot.CFrame = RootPart.CFrame * CFrame.new(0, 0.1, 0)
	end

	if KryptonSetConfig.Animations then
		local function AddAnimation(ID)
			local Animation = Instance.new("Animation")
			Animation.AnimationId = ID
			return Animation
		end

		local AnimationsToggled = true
		local JumpAnimTime = 0

		local Current = {
			Speed = 0,
			Animation = "",
			Instance = nil,
			AnimTrack = nil,
			KeyframeHandler = nil,
		}

		local AnimationTable = {
			Idle = AddAnimation("http://www.roblox.com/asset/?id=180435571"),
			Walk = AddAnimation("http://www.roblox.com/asset/?id=180426354"),
			Run = AddAnimation("Run.xml"),
			Jump = AddAnimation("http://www.roblox.com/asset/?id=125750702"),
			Fall = AddAnimation("http://www.roblox.com/asset/?id=180436148"),
			Climb = AddAnimation("http://www.roblox.com/asset/?id=180436334"),
			Sit = AddAnimation("http://www.roblox.com/asset/?id=178130996"),

			dance1 = AddAnimation("http://www.roblox.com/asset/?id=182435998"),
			dance2 = AddAnimation("http://www.roblox.com/asset/?id=182436842"),
			dance3 = AddAnimation("http://www.roblox.com/asset/?id=182436935"),
			wave = AddAnimation("http://www.roblox.com/asset/?id=128777973"),
			point = AddAnimation("http://www.roblox.com/asset/?dan=128853357"),
			laugh = AddAnimation("http://www.roblox.com/asset/?id=129423131"),
			cheer = AddAnimation("http://www.roblox.com/asset/?id=129423030"),
		}

		local function PlayAnimation(AnimName, TransitionTime)
			local Anim = AnimationTable[AnimName]

			if Anim ~= Current.Instance then
				if Current.AnimTrack then
					Current.AnimTrack:Stop(TransitionTime)
					Current.AnimTrack:Destroy()
				end

				Current.Speed = 1.0
				Current.AnimTrack = FakeHumanoid:LoadAnimation(Anim)
				Current.AnimTrack.Priority = Enum.AnimationPriority.Core
				Current.AnimTrack:Play(TransitionTime)

				Current.Animation = AnimName
				Current.Instance = Anim

				if Current.KeyframeHandler then
					Current.KeyframeHandler:Disconnect()
				end

				Current.KeyframeHandler = Current.AnimTrack.KeyframeReached:Connect(function(FrameName)
					if FrameName == "End" and AnimationTable[Current.Animation] then
						PlayAnimation("Idle", 0.1)
					end
				end)
			end
		end

		local function SetAnimationSpeed(Speed)
			Current.Speed = Speed
			Current.AnimTrack:AdjustSpeed(Speed)
		end

		local EventHandlers = {
			Running = function(Speed)
				if Speed > 0.01 then
					PlayAnimation("Walk", 0.1)
					SetAnimationSpeed(Speed / 14.5)
				else
					PlayAnimation("Idle", 0.1)
				end
			end,

			Jumping = function()
				PlayAnimation("Jump", 0.1)
				JumpAnimTime = 0.3
			end,

			Climbing = function(Speed)
				PlayAnimation("Climb", 0.1)
				SetAnimationSpeed(Speed / 12.0)
			end,

			FreeFalling = function()
				if JumpAnimTime <= 0 then
					PlayAnimation("Fall", 0.3)
				end
			end,
		}

		for EventName, Handler in EventHandlers do
			FakeHumanoid[EventName]:Connect(function(...)
				if AnimationsToggled then
					Handler(...)
				end
			end)
		end

		table.insert(RBXSignals,Player.Chatted:Connect(function(Message)
			local Context = Message and string.gsub(Message, "/e ", "")

			if AnimationsToggled and AnimationTable[Context] then
				PlayAnimation(Context, 0.1)
			end
		end))

		table.insert(RBXSignals, RunService.PostSimulation:Connect(function(DeltaTime)
			AnimationsToggled = Animate and Animate.Parent and Animate.Enabled
			JumpAnimTime = math.max(0, JumpAnimTime - DeltaTime)
		end))
	end

	FakeRig.Parent = Terrain
	FakeRoot.CFrame = RootPart.CFrame
	ChangeState(FakeHumanoid, Enum.HumanoidStateType.GettingUp)
	ChangeState(FakeHumanoid, Enum.HumanoidStateType.Landed)
end

-- // RunTime: Functions

local IsNetworkOwner = isnetworkowner or function(Part): bool
	return Part and Part.ReceiveAge == 0
end

local function ExtractNumbers(String: string | number)
	local ToString = tostring(String)
	return string.match(ToString, "%d+")
end

local function GetFirstPart(Parent: Instance) : Part
	return FindFirstChildOfClass(Parent, "Part") or WaitForChild(Parent, "Handle", 1)
end

local function GetFirstWeld(Parent: Instance) : Weld
	return FindFirstChild(Parent, "AccessoryWeld") or FindFirstChildOfClass(Parent, "Weld")
end

local function DestroyWeld(Parent: Instance)
	local Weld = GetFirstWeld(Parent)

	if Weld then
		Weld:Destroy()
	end
end

local function ObtainMeshAndTextureOfAccessory(Accessory: Accessory)
	local Handle = FindFirstChild(Accessory, "Handle")
	local IfMesh = FindFirstChildOfClass(Handle, "SpecialMesh")

	if IsA(Handle, "MeshPart") then
		return {MeshId = Handle.MeshId, TextureId = Handle.TextureID}

	elseif IfMesh then
		return {MeshId = IfMesh.MeshId, TextureId = IfMesh.TextureId}
	end
end

local function ExtractNumbers(String: string | number)
	local ToString = tostring(String)
	return string.match(ToString, "%d+")
end

local function FindAccessory(Parent: Instance, Texture: string | number, Mesh: string | number, Name: string)
	local InputMeshNumber = ExtractNumbers(Mesh)
	local InputTextureNumber = ExtractNumbers(Texture)

	for _, Accessory in GetChildren(Parent) do
		if IsA(Accessory, "Accessory") and Accessory.Name == Name then
			local HatData = ObtainMeshAndTextureOfAccessory(Accessory)

			if HatData then
				local MeshNumber = ExtractNumbers(HatData.MeshId)
				local TextureNumber = ExtractNumbers(HatData.TextureId)

				if MeshNumber == InputMeshNumber and TextureNumber == InputTextureNumber then
					return Accessory
				end
			end
		end
	end
end

local function RecreateAccessory(Accessory: Accessory)
	local FakeAccessory = Clone(Accessory)
	local FakeHandle = GetFirstPart(FakeAccessory)

	FakeHandle.Transparency = 1

	local FakeAttachment = FindFirstChildOfClass(FakeHandle, "Attachment")
	local RigAttachment = FindFirstChild(FakeRig, FakeAttachment and FakeAttachment.Name or "", true)

	local FakeHandleWeld = Instance.new("Weld")

	FakeHandleWeld.Name = "AccessoryWeld"
	FakeHandleWeld.Part0 = FakeHandle
	FakeHandleWeld.C0 = FakeAttachment.CFrame

	DestroyWeld(FakeHandle)

	if RigAttachment then
		FakeHandleWeld.C1 = RigAttachment.CFrame
		FakeHandleWeld.Part1 = RigAttachment.Parent
	else
		FakeHandleWeld.Part1 = FindFirstChild(FakeRig, "Head")
	end

	FakeHandleWeld.Parent = FakeHandle
	FakeAccessory.Parent = FakeRig

	return FakeAccessory
end

local function ProcessAccessory(Accessory: Accessory, Function)
	if not Accessory or table.find(Blacklist, Accessory) then
		return
	end

	table.insert(Blacklist, Accessory)

	local Handle = GetFirstPart(Accessory)

	if Handle and not HatsInUse[Handle] then
		Function(Handle)
	end
end

local function SetUpHatConfig()	
	for _, Hat in GetDescendants(FakeRig) do
		if IsA(Hat, "Accessory") then
			Hat:Destroy()
		end
	end

	for _, Value in HatsWithDifferentAligns do
		local Accessory = FindAccessory(Character, Value[1], Value[2], Value[3])

		ProcessAccessory(Accessory, function(Handle)
			local Part1 = Value[4]

			if Part1 and Part1.Parent then
				HatsInUse[Handle] = { Part1, Value[5] or CFrame.identity }
			end
		end)
	end

	for Index, Data in Hats do
		for _, Info in Data do
			local Accessory = FindAccessory(Character, Info.Texture, Info.Mesh, Info.Name)

			ProcessAccessory(Accessory, function(Handle)
				HatsInUse[Handle] = { FindFirstChild(FakeRig, Index), Info.Offset }
			end)

			if LimitHatsPerLimb then
				continue
			end
		end
	end

	for _, Accessory in GetChildren(Character) do
		if IsA(Accessory, "Accessory") then
			ProcessAccessory(Accessory, function(Handle)
				local FakeAccessory = RecreateAccessory(Accessory)
				HatsInUse[Handle] = { GetFirstPart(FakeAccessory), CFrame.identity }
			end)
		end
	end
end

local IsNetworkOwner = isnetworkowner or function(Part: Part)
	return Part.ReceiveAge == 0 
end

local function GetRandomRadius() : Vector3
	return Vector3.new(math.random(-TeleportOffsetRadius, TeleportOffsetRadius), 0.5, math.random(-TeleportOffsetRadius, TeleportOffsetRadius))
end

local function ArePlayersNearby() : boolean
	local Output = nil

	for _, Part in Workspace:GetPartBoundsInRadius(TeleportOffset, 10) do
		local Model = Part.Parent

		if IsA(Model, "Model") then
			if FindFirstChildOfClass(Model, "Humanoid") and not (Model == Character and Model == FakeRig) then
				Output = true
			end
		end
	end

	return Output
end

local function FlingModels() 
	for _, Model in FlingableTargets do
		local PrimaryPart = Model.PrimaryPart

		if PrimaryPart then
			for _ = 1, 16 do
				RootPart.CFrame = CFrameNew(PrimaryPart.Position + PrimaryPart.AssemblyLinearVelocity * Player:GetNetworkPing() * 30)
				RootPart.AssemblyLinearVelocity = Vector3New(16000, 16000, 16000)

				if PrimaryPart.AssemblyAngularVelocity.Magnitude > 75 then
					break
				end
			end
		end
	end

	table.clear(FlingableTargets)
end

local function BringCharacter()
	local Time = 0
	
	while WaitTime > Time do
		if RootPart then
			RootPart.AssemblyLinearVelocity = Vector3.zero
			RootPart.AssemblyAngularVelocity = Vector3.zero
			RootPart.CFrame = CFrame.new(TeleportOffset.X, NoBodyNearby and FallenPartsDestroyHeight or TeleportOffset.Y, TeleportOffset.Y)
		end

		Time += task.wait()
	end
end

local function UpdateCameraCFrame() 
	PreviousCameraCFrame = Camera.CFrame

	RunService.PreRender:Wait()
	Camera.CFrame = PreviousCameraCFrame
end

local function ChangeCameraSubject()
	if Camera and Camera.CameraSubject ~= FakeHumanoid then
		Camera.CameraSubject = FakeHumanoid
		UpdateCameraCFrame()
	end
end

local function OnPreRender() 
	if Camera then
		ChangeCameraSubject()

		if Camera.CameraType ~= CamCustomType then
			Camera.CameraSubject = CamCustomType
		end
	end
	
	if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then	
		local Position = FakeRoot.Position
		local CamLookVector = Camera.CFrame.LookVector
		
		FakeRoot.CFrame = CFrame.lookAt(Position, Position + Vector3.new(CamLookVector.X, 0, CamLookVector.Z))
	end
	
	for Handle, Data in HatsInUse do
		local Part1 = Data[1]
		local Offset = Data[2]
		
		if IsNetworkOwner(Handle) then
			local CFrameOffset = Part1.CFrame * Offset
			Handle.CFrame = CFrameOffset + ReverseSleep
		end
	end
end

local function OnPostSimulation()
	for Handle, Data in HatsInUse do
		local Part1 = Data[1]
		local Offset = Data[2]
		
		local Part1Magnitude = Part1.Size.Magnitude
		local Part1Velocity = Part1.AssemblyLinearVelocity * Part1Magnitude
		
		local CalculatedVel = Part1Velocity * 2.275
		local ClampedAxisY = math.clamp(Part1Velocity.Y, SafeYAxis, 512)	
		
		if IsNetworkOwner(Handle) then
			local Velocity = Vector3.new(CalculatedVel.X, ClampedAxisY, CalculatedVel.Z)
			local CFrameOffset = Part1.CFrame * Offset

			Handle.AssemblyLinearVelocity = Velocity
			Handle.AssemblyAngularVelocity = Part1.AssemblyAngularVelocity
			Handle.CFrame = CFrameOffset + ReverseSleep
		end
	end
	
	if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then	
		local Position = FakeRoot.Position
		local CamLookVector = Camera.CFrame.LookVector --* 1
		
		FakeRoot.CFrame = CFrame.lookAt(Position, Position + Vector3.new(CamLookVector.X, 0, CamLookVector.Z))
	end
	
	FakeHumanoid.Jump = Humanoid.Jump
	Move(FakeHumanoid, Humanoid.MoveDirection)
end

local function OnPreSimulation() 
	SetCore(StarterGui, "ResetButtonCallback", RespawnEvent)
	ReverseSleep = Vector3.new(0.0075 * math.sin(os.clock() * 7), 0, 0.0065 * math.cos(os.clock() * 3))
	SafeYAxis = 35 - 3 * math.sin(os.clock() * 10)

	if SetSimulationRadius and CanCallSimRadius then
		Player.SimulationRadius = 2147483647
	end

	for _, Part in Descendants do
		if IsA(Part, "BasePart") then
			Part.CanCollide = false
			Part.CanTouch = false
			Part.CanQuery = false
		end
	end

	if NoCollisions then
		for _, Part in FakeRigChildren do
			if IsA(Part, "BasePart") then
				Part.CanCollide = false
				Part.CanTouch = false
				Part.CanQuery = false
			end
		end
	end
	
	if AntiVoiding then
		if FakeRoot.Position.Y < FallenPartsDestroyHeight then
			FakeRoot.CFrame = CFrameBackup
			FakeRoot.AssemblyLinearVelocity = Vector3.zero
			FakeRoot.AssemblyAngularVelocity = Vector3.zero
		end
	end
end

local function UponParentChange()
	if not FakeRig:IsDescendantOf(Workspace) then
		CancelScript()
	end
end

local function OnCharacterAdded(NewCharacter: Model)
	UpdateCameraCFrame()

	if NewCharacter ~= FakeRig then
		table.clear(HatsInUse)
		table.clear(Descendants)
		table.clear(FakeRigChildren)
		table.clear(Blacklist)

		Character = NewCharacter
		Humanoid = GetInstanceWithTime(Character, "Humanoid", nil, 3)
		RootPart = GetInstanceWithTime(Character, "Part", "HumanoidRootPart", 3)

		if Humanoid and RootPart then
			SetStateEnabled(Humanoid, Enum.HumanoidStateType.Seated, false)
			SetStateEnabled(Humanoid, Enum.HumanoidStateType.Dead, true)
			TeleportOffset = FakeRoot.Position + GetRandomRadius()
			
			if Flinging then
				FlingModels()
			end

			while ArePlayersNearby() do
				TeleportOffset = FakeRoot.Position + GetRandomRadius()
				task.wait()
			end
			
			if DisableCharacterScripts then
				for _, Script in Descendants do
					if IsA(Script, "LocalScript") then
						Script.Disabled = true
					end
				end
			end
			
			BringCharacter()
			UpdateCameraCFrame()
			
			ChangeState(Humanoid, Enum.HumanoidStateType.Dead)
			task.wait(0.175)

			SetUpHatConfig()
			FakeRigChildren = GetChildren(FakeRig)
		end
	end
end

table.insert(RBXSignals, Player.CharacterAdded:Connect(OnCharacterAdded))
table.insert(RBXSignals, RunService.PostSimulation:Connect(OnPostSimulation))
table.insert(RBXSignals, RunService.PreSimulation:Connect(OnPreSimulation))
table.insert(RBXSignals, RunService.PreRender:Connect(OnPreRender))
table.insert(RBXSignals, RespawnEvent.Event:Connect(CancelScript))

table.insert(RBXSignals, FakeRoot:GetPropertyChangedSignal("Parent"):Connect(UponParentChange))
table.insert(RBXSignals, Camera:GetPropertyChangedSignal("CameraSubject"):Connect(ChangeCameraSubject))

SetCoreGuiEnabled(StarterGui, Enum.CoreGuiType.Health, false)
SetStateEnabled(Humanoid, Enum.HumanoidStateType.Seated, false)
SetStateEnabled(Humanoid, Enum.HumanoidStateType.Dead, true)

if KryptonSetConfig.PermanentDeath and replicatesignal then
	replicatesignal(Player.ConnectDiedSignalBackend)
	task.wait(Players.RespawnTime + 0.65)
	
	if NoBodyNearby then
		local Offset = RootPart.Position
		RootPart.CFrame = CFrame.new(Offset.X, FallenPartsDestroyHeight, Offset.Y)
		task.wait(0.175)
	end
	
	ChangeState(Humanoid, Enum.HumanoidStateType.Dead)
else
	ChangeState(Humanoid, Enum.HumanoidStateType.Dead)
end

task.wait(0.175)
SetUpHatConfig()
FakeRigChildren = GetChildren(FakeRig)

return {
	GetCharacter = function() -- Returns FakeRig Model, needed for scripts.
		return FakeRig
	end,

	GetHumanoid = function() -- Returns GetHumanoid
		return FakeHumanoid
	end,

	GetRootPart = function() -- Returns HumanoidRootPart
		return FakeRoot
	end,

	GetHatInformation = function(Hat) -- Returns HumanoidRootPart
		local HatInfo = ObtainMeshAndTextureOfAccessory(Hat)
		HatInfo.Name = Hat.Name

		return HatInfo
	end,

	GetRealCharacter = function() -- Returns RealRig Model, needed for scripts.
		repeat
			task.wait()
		until Player.Character

		return Player.Character
	end,

	SetHatAlign = function(HatInformation, Part1, Offset) -- Aligns Hat.
		assert(typeof(HatInformation) == "table", "HatInformation is not an table.")
		assert(Part1 and Part1:IsA("BasePart"), "Part1 is not a part.")
		assert(typeof(Offset) == "CFrame", "Offset is not a part.")

		local TextureId = HatInformation.TextureId
		local MeshId = HatInformation.MeshId
		local Name = HatInformation.Name

		local Accessory = nil
		local Timeout = 3
		local Current = 0

		while not Accessory and Timeout > Current do
			Accessory = FindAccessory(Player.Character, TextureId, MeshId, Name)

			Current += task.wait()
		end

		if not Accessory then
			error("Accessory has not been found in Character.")
		end

		local Handle = GetFirstPart(Accessory)

		if Handle then
			local Dictionary = table.find(HatsInUse, Handle)
			table.remove(HatsInUse, Dictionary)

			table.insert(HatsWithDifferentAligns, { TextureId, MeshId, Name, Part1, Offset })
			HatsInUse[Handle] = { Part1, Offset }
		end
	end,

	DisconnectHatAlign = function(HatInformation) -- Disconnects hat
		assert(typeof(HatInformation) == "table", "HatInformation is not an table.")

		local Accessory = nil
		local Timeout = 3
		local Current = 0

		local TextureId = HatInformation.TextureId
		local MeshId = HatInformation.MeshId
		local Name = HatInformation.Name

		while not Accessory and Timeout > Current do
			Accessory = FindAccessory(Player.Character, TextureId, MeshId, Name)

			Current += task.wait()
		end		

		if not Accessory then
			error("Accessory has not been found in Character.")
		end

		for Table, Value in HatsWithDifferentAligns do
			local UsedAccessory = FindAccessory(Character, Value[1], Value[2], Value[3])

			if UsedAccessory and UsedAccessory == Accessory then
				local UsedHandle = GetFirstPart(UsedAccessory)

				local Dictionary = table.find(HatsInUse, UsedHandle)
				table.remove(HatsInUse, Dictionary)

				local Dictionary2 = table.find(HatsWithDifferentAligns, Table) -- seems ugly but idc
				table.remove(HatsWithDifferentAligns, Dictionary)

				if UsedHandle then
					local FakeAccessory = RecreateAccessory(UsedAccessory)

					if FakeAccessory then
						HatsInUse[UsedHandle] = { GetFirstPart(FakeAccessory), CFrame.identity }
					end
				end
			end
		end
	end,

	SWait = task.wait, -- Stepped Wait

	SetAnimationState = function(Status) -- Stops Animations
		local Animator = FindFirstChildOfClass(FakeHumanoid, "Animator")
		local Animate = FindFirstChild(FakeRig, "Animate")

		if Animate then
			Animate.Disabled = not Status
		end

		if not Status and Animator then
			for _, Track in Animator:GetPlayingAnimationTracks() do
				Track:Stop()
			end
		end
	end,

	GetLoadLibrary = function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/KadeTheExploiter/Uncategorized-Scripts/main/LoadLib.lua"))()
	end,

	CallFling = function(Model)
		assert(IsA(Model, "Model"), "Not a Model.")

		if Model ~= Character and Model ~= FakeRig then
			table.insert(FlingableTargets, Model)
		end
	end,

	CreateTempSignal = function(Signal)
		table.insert(TempSignals, Signal)
	end,

	DisconnectTempSignals = function()
		for _, Signal in TempSignals do
			Signal:Disconnect()
		end
	end,

	GetJoints = function()
		return Joints
	end,

	GetWeld = function(Object)
		assert(typeof(Object) == "Instance", "Argument is not an instance.")

		if IsA(Object, "Accessory") then
			local Part = GetFirstPart(Object)

			if Part then
				return GetFirstWeld(Part)
			end
		elseif IsA(Object, "BasePart") then
			return GetFirstWeld(Object)
		end
	end,
}
